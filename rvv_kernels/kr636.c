// Copyright 2019 OCULUS VR. All rights reserved.

#include <stdio.h>

//Stream of small matrix multiplication <6,3> x <3,6>
//Single precision floating point
#define ROW1     6
#define COL1     3
#define COL2     6
#define ITR     10 // could be tens of thousands matrix multiplication


//<6,3> matrices; stored row-major in memory
float MatA[ITR * ROW1 * COL1] = {
		  51.291,  11.597,  14.492,  46.048,  7.8085,  71.784,   35.04,  36.925,  66.171,  9.5046,  3.3628,  43.187,  43.367,  19.215,  44.603,  70.924,  47.136,  50.833,
		  52.809,  39.334,  78.595,  57.288,  80.437,  41.073,  36.082,  1.1081,  11.939,  33.648,  23.311,  63.437,  17.327,  93.385,  86.239,  8.6118,   22.68,  15.824,
		  60.119,  27.203,  32.038,  11.761,    92.8,  65.788,   62.61,  92.132, 0.17629,  83.512,  54.202,  62.895,  94.041,  81.289,  78.529,  41.556,  16.638,  29.469,
		  78.968,  34.506,  4.6425,  21.589,  41.243,    27.1,  40.321,  71.013,  67.789,   80.24,  14.283,  21.939,  86.215,  57.745,  34.016,  14.377,  25.603,  13.981,
		  83.286,  59.869,  44.403,  93.988,  12.518,  75.743,  52.519,  83.459,  20.977,  92.158,  94.526,  60.073,  6.2254,  90.567,  47.156,  30.396,  60.662,  46.859,
		  65.955,  12.538,  74.998,  10.752,  24.127,   88.44,   13.53,  97.675,  19.242,  90.535,  30.153,  96.968,  21.974,  75.334,  46.172,  24.752,  43.266,  21.085,
		  70.479,  12.316,   14.27,  39.308,  90.805,  40.885,  52.276,  52.436,  58.185,  10.717,  88.328,   12.33,  20.708,  23.244,  36.459,  37.158,  68.103,  73.684,
		  3.7413,  35.846,  86.254,   79.45,  70.547,  64.642,  19.428,  75.242,  35.787,  27.107,  96.769,  67.285,  82.003,  2.8305,  59.334,  31.804,   72.29,  26.078,
		  88.284,  70.473,  20.804,  93.403,  33.115,  56.521,  30.054,   55.49,  40.752,  19.994,  28.782,  19.186,  35.618,  34.663,  55.747,   28.95,  78.344,  43.465,
		  9.3426,  49.362,   22.18,  21.393,   27.51,  85.859,  59.589,   57.16,  36.738,  7.4429,  85.165,  52.756,  93.446,  69.101,  72.607,  49.036,   84.43,  1.8172};

//<3,6> matrices; stored row-major in memory
float MatB[ITR * COL1 * COL2] ={
		  41.435,   21.35,   76.54,  31.021,  40.404,  68.696,  94.389,  27.587,  10.467,  64.796,  70.935,  81.723,  99.246,   51.81,  23.093,  32.423,  96.172,  16.344,
		  95.189,  81.493,  80.899,  99.028,  70.171,  74.398,  36.795,  56.747,  62.669,  64.591,  61.096,  6.8325,  5.3122,  53.506,  73.338,  77.067,  37.358,  33.605,
		 0.73487,  23.978,  31.871,  37.889,  1.9904,  26.419,  50.884,   93.53,  54.566,  1.5218,  51.898,  19.624,  9.3071,   57.46,  84.521,  77.111,   48.66,  28.345,
		  96.959,  59.129,  25.393,  60.897,  10.904,  13.756,  86.078,   83.94,  85.448,  99.864,  62.317,   99.67,  10.398,  72.221,  16.283,  10.639,  67.925,  60.614,
		  39.773,  94.145,  4.2578,  20.434,  82.208, 0.30583,  62.591,  94.201,  61.325,  35.038,  61.986,  40.042,  62.242,  31.017,  82.116,  75.598,  1.6303,  91.972,
		  73.602,  25.733,  67.849,  36.811,  36.701,  56.927,  31.317,  98.623,  38.992,   85.23,  34.125,  71.082,  44.459,  52.018,  32.661,  62.024,  33.912,  74.492,
		  79.842,  7.0592,  15.671,  84.212,  96.892,  46.236,  3.1835,  43.927,   90.72,  53.472,   70.29,  89.527,  5.4743,  80.503,  29.606,  3.4448,  70.479,  72.548,
		  17.805,  34.699,  13.396,   11.41,  27.071,  78.984,  42.716,  83.483,  44.142,  61.417,  75.119,  88.177,  34.987,  1.5061,  1.6429,   36.57,  18.176,  85.691,
		  13.208,  97.478,  51.896,  80.641,  74.922,  5.0636,  93.929,  12.596,  14.921,  33.491,   5.762,  4.6163,  58.232,  4.0907,  80.168,  90.675,  41.221,  86.287,
		  33.409,  32.101,  76.206,  59.383,  43.906,  42.753,   7.772,  26.076,  1.3961,  52.128,  21.393,  51.763,  23.986,  53.024,  63.554,  20.363,  56.878,   72.63};

//<6,6> matrices; multiplication results written back to memory row-major
float MatC[ITR * ROW1 * COL2];


/* Vanilla C implementation
   Target Kernel for optimization
   We are interested in :
    - gate count of the target core
    - Cycles per matrix multiplication
    - Memory BW analysis
    - MAC array utilization
    - Rough power-estimation per matrix multiplication
*/
int main(int argc, char **argv)
{

  int z, y, x, k;
  float * a_ref = MatA;
  float * b_ref = MatB;
  float * c_ref = MatC;

  for (z = 0; z < ITR; z++) {
	  for (y = 0; y < ROW1; y++) {
	      for (x = 0; x < COL2; x++) {
  		      c_ref[COL2 * y + x] = 0;
		      for (k = 0; k < COL1; k++) {
				  c_ref[COL2 * y + x] += a_ref[COL1 * y + k] * b_ref[COL2 * k + x];
		      }
	      }
	  }

	  a_ref += (ROW1*COL1);
	  b_ref += (COL1*COL2);
	  c_ref += (ROW1*COL2);
  }


  c_ref = MatC;
  for (z = 0; z < ITR; z++) {
	  printf("\n");
	  for (y = 0; y < ROW1*COL2; y++) {
		  printf("%8.3f\t,",c_ref[y]);
	  }

	  c_ref += (ROW1*COL2);
  }

  return(0);
}

